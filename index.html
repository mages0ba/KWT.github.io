<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KWT project</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');
        body {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            min-height: 100vh; margin: 0; background-color: #000;
            font-family: 'DotGothic16', sans-serif; overflow: hidden; color: #eee;
        }
        canvas { border: 2px solid #ccc; display: block; margin-bottom: 20px; }
        
        .ui-container {
            position: fixed; top: 20px; left: 20px; right: 20px;
            display: flex;
            align-items: center; z-index: 100;
        }

        .button-group {
            margin-left: auto;
        }

        .game-info { color: #00ff00; font-size: 16px; text-shadow: 1px 1px #005500; }
        .button-group button {
            padding: 10px 15px; font-size: 16px; font-family: 'DotGothic16', sans-serif;
            color: white; border: 2px solid #fff; border-radius: 5px;
            cursor: pointer; margin-left: 10px; transition: background-color 0.2s, color 0.2s;
        }
        #instagramModeBtn { background-color: #C13584; border-color: #C13584; }
        #twitterModeBtn { background-color: #1DA1F2; border-color: #1DA1F2; }
        #commentModeBtn { background-color: #4CAF50; border-color: #4CAF50; }
        #resetButton { background-color: #ff4500; border-color: #ff4500; }
        .button-group button.active { background-color: #fff; color: #000; }

        .comment-room {
            display: none;
            flex-direction: column;
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 80%; max-width: 500px;
            height: 70%; max-height: 600px;
            background-color: #1a1a1a;
            border: 2px solid #ccc;
            border-radius: 15px;
            padding: 20px;
            box-sizing: border-box;
            z-index: 200;
        }
        .comment-room h2 { margin-top: 0; text-align: center; color: #4CAF50; }
        .comment-room textarea {
            width: 100%;
            height: 100px;
            background-color: #333;
            border: 1px solid #777;
            border-radius: 5px;
            color: #eee;
            font-family: 'DotGothic16', sans-serif;
            font-size: 16px;
            padding: 10px;
            box-sizing: border-box;
            resize: none;
        }
        .comment-room button {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            font-family: 'DotGothic16', sans-serif;
            font-size: 18px;
            cursor: pointer;
            background-color: #4CAF50;
            border: none;
            color: white;
            border-radius: 5px;
        }
      .commentInput{
        margin: 20px 18px 15px 25px;
        padding-bottom: 10px;
        font-size: 13px;
      }
        .comment-log {
            flex-grow: 1;
            margin-top: 20px;
            padding: 10px;
            background-color: #000;
            border: 1px solid #555;
            border-radius: 5px;
            overflow-y: auto;
        }
        .comment-log p {
    margin: 10px 15px 10px 20px;
    padding-bottom: 10px;
    border-bottom: 1px dashed #444;
    color: #ddd;
    font-size: 13px; /* üëà Ïù¥ Ï§ÑÏùÑ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî */
}
        .comment-log p:last-child { border-bottom: none; }
    </style>
</head>
<body>
    <div class="ui-container">
        <div class="game-info" id="gameInfo"></div>
        <div class="button-group">
            <button id="instagramModeBtn">Instagram</button>
            <button id="twitterModeBtn">Twitter</button>
            <button id="commentModeBtn">Comment</button>
            <button id="resetButton">New Maze</button>
        </div>
    </div>
    
    <div class="comment-room" id="commentRoom">
        <h2>LEAVE A COMMENT</h2>
        <textarea id="commentInput" placeholder="Your comment..."></textarea>
        <button id="submitCommentBtn">Submit</button>
        <div class="comment-log" id="commentLog">
        </div>
    </div>

    <script>
        // --- Ï†ÑÏó≠ Î≥ÄÏàò ÏÑ§Ï†ï ---
        let cols, rows; let cellSize = 35; let grid = []; let mazeGenerated = false;
        const MAZE_COLS = 15; const MAZE_ROWS = 15;

        let playerX, playerY, playerSize, playerMoveSpeed, playerAngle = 0;
        let wallsToConsider = [];
        let balls = []; let ballsPlaced = false; let gameClear = false;
        let currentGameMode = 'instagram'; let score = 0;

        let dangerBallsEatenCount = 0; const DANGER_BALL_LIMIT = 5;

        let timer = 60; const TIME_LIMIT = 60; let startTime;
        let scoreGoal;
        let timerStarted = false;

        const instagramColors = [ '#833AB4', '#C13584', '#E1306C', '#FD1D1D', '#F56040', '#F77737', '#FCAF45', '#FFDC80' ];
        const twitterColors = [ '#1DA1F2', '#14171A', '#657786', '#AAB8C2', '#E1E8ED', '#F5F8FA', '#FFAD1F' ];
        const DANGER_COLOR = '#E0245E';
        
        // ‚ÄºÔ∏è [ÏàòÏ†ïÎêú Î∂ÄÎ∂Ñ] ÏöîÏ≤≠ÌïòÏã† URLÎ°ú Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.
        const WEB_APP_URL = "https://script.google.com/macros/s/AKfycbzx3XcPg7vbkvh2SlgkecYOmK3V085rRdPWrep9Emq5Bb_e5O_214_oQRPX1sKSBsKWuw/exec";

        class Ball {
            constructor(i, j) {
                this.i = i; this.j = j; this.x = i * cellSize + cellSize / 2; this.y = j * cellSize + cellSize / 2;
                this.isDanger = false;
                if (currentGameMode === 'instagram') {
                    this.color = random(instagramColors); this.size = cellSize * random(0.2, 0.6);
                    this.points = floor(map(this.size, cellSize * 0.2, cellSize * 0.6, 1, 6));
                } else {
                    const DANGER_BALL_MAX = 5;
                    let currentDangerBalls = balls.filter(b => b.isDanger).length;
                    if (currentDangerBalls < DANGER_BALL_MAX && random(1) < 0.2) {
                        this.isDanger = true; this.color = DANGER_COLOR; this.points = 0;
                    } else {
                        this.isDanger = false; this.color = random(twitterColors); this.points = 1;
                    }
                    this.size = cellSize * 0.4;
                }
            }
            show() { fill(this.color); noStroke(); ellipse(this.x, this.y, this.size, this.size); }
        }
        
        function initializeGame() {
            cols = MAZE_COLS; rows = MAZE_ROWS;
            let canvasWidth = cols * cellSize; let canvasHeight = rows * cellSize;
            resizeCanvas(canvasWidth, canvasHeight);
            grid = []; balls = []; wallsToConsider = [];
            mazeGenerated = false; ballsPlaced = false; gameClear = false;
            score = 0; dangerBallsEatenCount = 0;
            timer = TIME_LIMIT;
            timerStarted = false;

            let totalCells = cols * rows; let numBalls;
            if (currentGameMode === 'instagram') { numBalls = floor(totalCells * 0.4); } else { numBalls = floor(totalCells * 0.2); }
            for (let j = 0; j < rows; j++) { for (let i = 0; i < cols; i++) { grid.push(new Cell(i, j)); } }
            let startCell = grid[0]; startCell.inMaze = true; startCell.addWallsToConsider();
            let possibleLocations = grid.slice(1); shuffle(possibleLocations, true);
            for (let i = 0; i < numBalls && i < possibleLocations.length; i++) {
                let cell = possibleLocations[i]; balls.push(new Ball(cell.i, cell.j));
            }
            
            if (currentGameMode === 'instagram') {
                scoreGoal = 70;
            }

            playerX = 0.5 * cellSize; playerY = 0.5 * cellSize; playerSize = cellSize * 0.7; playerMoveSpeed = floor(cellSize / 8) || 1;
            updateButtonUI();
            loop();
        }

        function draw() {
            background(0);
            if (mazeGenerated) {
                if (currentGameMode === 'instagram' && !gameClear) {
                    if (timerStarted) {
                        let elapsed = (millis() - startTime) / 1000;
                        timer = TIME_LIMIT - elapsed;
                    }
                    if (timer <= 0) {
                        gameClear = true;
                        noLoop();
                        if (score >= scoreGoal) {
                            textAlign(CENTER, CENTER);
                            fill(0, 255, 0);
                            textSize(width / 10);
                            let numChecks = floor(score / scoreGoal);
                            let checkSymbols = '‚úî'.repeat(numChecks);
                            text(`Success ${checkSymbols}`, width / 2, height / 2);
                        } else {
                            textAlign(CENTER, CENTER);
                            fill(255, 0, 0);
                            textSize(width / 8);
                            text("GAME OVER", width / 2, height / 2);
                            setTimeout(initializeGame, 2000);
                        }
                        return;
                    }
                }

                for (let cell of grid) cell.show(); for (let ball of balls) ball.show();

                if (!gameClear) {
                    checkPlayerMovementAndCollision();
                    for (let i = balls.length - 1; i >= 0; i--) {
                        let d = dist(playerX, playerY, balls[i].x, balls[i].y);
                        if (d < playerSize / 2 + balls[i].size / 2) {
                            let collectedBall = balls.splice(i, 1)[0];
                            if (currentGameMode === 'twitter') {
                                if (collectedBall.isDanger) {
                                    dangerBallsEatenCount++;
                                    if (dangerBallsEatenCount >= DANGER_BALL_LIMIT) {
                                        gameClear = true; textAlign(CENTER, CENTER); fill(DANGER_COLOR); textSize(width / 8);
                                        text("GAME OVER", width / 2, height / 2);
                                        noLoop(); setTimeout(initializeGame, 2000); return; 
                                    }
                                } else { score += collectedBall.points; spawnNewBalls(2); }
                            } else { score += collectedBall.points; }
                        }
                    }
                }

                fill(255, 255, 0); noStroke(); push(); translate(playerX, playerY); rotate(playerAngle); arc(0, 0, playerSize, playerSize, PI / 6, TWO_PI - PI / 6, PIE); pop();
                
                if (currentGameMode === 'instagram') {
                    let checkmarksString = '';
                    if (scoreGoal > 0) {
                        let numChecks = floor(score / scoreGoal);
                        const blueCheck = `<span style="color: #007bff;"> ‚úî</span>`;
                        checkmarksString = blueCheck.repeat(numChecks);
                    }
                    select('#gameInfo').html(`Score: ${score}${checkmarksString} | Goal: ${scoreGoal} | Time: ${max(0, floor(timer))}`);

                    if (balls.length === 0 && !gameClear) {
                        gameClear = true;
                        textAlign(CENTER, CENTER); fill(0, 255, 0); textSize(width / 10);
                        text("PERFECT CLEAR!", width / 2, height / 2);
                        noLoop();
                    }
                } else {
                    select('#gameInfo').html(`Score: ${score} | Red: ${dangerBallsEatenCount}/${DANGER_BALL_LIMIT}`);
                }
            } else {
                let stepsPerFrame = 100;
                for (let i = 0; i < stepsPerFrame; i++) { if (wallsToConsider.length > 0) { let randomIndex = floor(random(wallsToConsider.length)); let wall = wallsToConsider.splice(randomIndex, 1)[0]; let cell1 = wall.c1; let cell2 = wall.c2; if (cell1.inMaze !== cell2.inMaze) { removeWallsBetween(cell1, cell2, wall.d1, wall.d2); let newCell = cell1.inMaze ? cell2 : cell1; newCell.inMaze = true; newCell.addWallsToConsider(); } } else { mazeGenerated = true; break; } }
                textAlign(CENTER, CENTER); fill(255); textSize(32); text("ÎØ∏Î°ú ÏÉùÏÑ± Ï§ë...", width / 2, height / 2);
            }
        }
        
        function setGameMode(mode) {
            const commentRoom = select('#commentRoom');
            const gameCanvas = select('canvas');
            const gameInfo = select('#gameInfo');

            if (currentGameMode === mode) { return; }

            if (mode === 'comment') {
                currentGameMode = 'comment';
                commentRoom.style('display', 'flex');
                gameCanvas.style('display', 'none');
                gameInfo.style('display', 'none');
                noLoop();
                loadComments();
            } else { 
                commentRoom.style('display', 'none');
                gameCanvas.style('display', 'block');
                gameInfo.style('display', 'block');
                currentGameMode = mode;
                initializeGame();
            }
            updateButtonUI();
        }

        function updateButtonUI() {
            select('#instagramModeBtn').removeClass('active');
            select('#twitterModeBtn').removeClass('active');
            select('#commentModeBtn').removeClass('active');

            if (currentGameMode === 'instagram') {
                select('#instagramModeBtn').addClass('active');
            } else if (currentGameMode === 'twitter') {
                select('#twitterModeBtn').addClass('active');
            } else if (currentGameMode === 'comment') {
                select('#commentModeBtn').addClass('active');
            }
        }

        function spawnNewBalls(count) { let ballPositions = new Set(balls.map(b => `${b.i},${b.j}`)); let emptyCells = grid.filter(cell => !ballPositions.has(`${cell.i},${cell.j}`)); shuffle(emptyCells, true); for (let i = 0; i < count && i < emptyCells.length; i++) { let cell = emptyCells[i]; balls.push(new Ball(cell.i, cell.j)); } }
        
        function setup() {
            createCanvas(MAZE_COLS * cellSize, MAZE_ROWS * cellSize);
            frameRate(60);
            select('#instagramModeBtn').mousePressed(() => setGameMode('instagram'));
            select('#twitterModeBtn').mousePressed(() => setGameMode('twitter'));
            select('#commentModeBtn').mousePressed(() => setGameMode('comment'));
            select('#resetButton').mousePressed(initializeGame);
            select('#submitCommentBtn').mousePressed(submitComment);
            initializeGame();
        }
        
        function loadComments() {
            const commentLog = select('#commentLog');
            commentLog.html('loading...');

            fetch(WEB_APP_URL)
                .then(response => response.json())
                .then(data => {
                    commentLog.html('');
                    if (data.result === 'success' && data.comments) {
                        data.comments.forEach(commentText => {
                            let p = createP(commentText);
                            p.parent(commentLog);
                        });
                        commentLog.elt.scrollTop = commentLog.elt.scrollHeight;
                    }
                })
                .catch(error => {
                    console.error("ÎåìÍ∏Ä Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®:", error);
                    commentLog.html('ÎåìÍ∏ÄÏùÑ Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.');
                });
        }
        
        function submitComment() {
            const commentInput = select('#commentInput');
            const commentLog = select('#commentLog');
            const commentText = commentInput.value();

            if (commentText.trim() === '') {
                alert('ÎåìÍ∏Ä ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.'); return;
            }

            const submitBtn = select('#submitCommentBtn');
            submitBtn.html('Ï†ÑÏÜ° Ï§ë...');
            submitBtn.attribute('disabled', '');

            fetch(WEB_APP_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: new URLSearchParams({ 'comment': commentText })
            })
            .then(response => {
                if (!response.ok) { throw new Error('ÏÑúÎ≤Ñ ÏùëÎãµ Ïò§Î•ò: ' + response.statusText); }
                return response.json();
            })
            .then(data => {
                if(data.result === 'success') {
                    commentInput.value('');
                    loadComments();
                } else { throw new Error('ÏÑúÎ≤ÑÍ∞Ä ÎåìÍ∏Ä Ï†ÄÏû•ÏùÑ Ïã§Ìå®ÌñàÏäµÎãàÎã§.'); }
            })
            .catch(error => {
                console.error('Ï†ÑÏÜ° Ïã§Ìå®:', error);
                alert('ÎåìÍ∏Ä Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
            })
            .finally(() => {
                submitBtn.html('Submit');
                submitBtn.removeAttribute('disabled');
            });
        }

        class Cell { 
            constructor(i, j) { 
                this.i = i; this.j = j; this.walls = [true, true, true, true]; this.inMaze = false; 
            } 
            index(i, j) { 
                if (i < 0 || j < 0 || i > cols - 1 || j > rows - 1) return -1; return i + j * cols; 
            } 
            addWallsToConsider() { 
                let neighbors = [{ cell: grid[this.index(this.i, this.j - 1)], dir: 0 }, { cell: grid[this.index(this.i + 1, this.j)], dir: 1 }, { cell: grid[this.index(this.i, this.j + 1)], dir: 2 }, { cell: grid[this.index(this.i - 1, this.j)], dir: 3 }]; 
                for (let neighborInfo of neighbors) { 
                    let neighbor = neighborInfo.cell; 
                    if (neighbor && !neighbor.inMaze) { 
                        let wallExists = false; let oppDir; 
                        if (neighborInfo.dir === 0) oppDir = 2; else if (neighborInfo.dir === 1) oppDir = 3; else if (neighborInfo.dir === 2) oppDir = 0; else if (neighborInfo.dir === 3) oppDir = 1; 
                        for (let w of wallsToConsider) { 
                            if ((w.c1 === this && w.c2 === neighbor && w.d1 === neighborInfo.dir) || (w.c1 === neighbor && w.c2 === this && w.d1 === oppDir)) { 
                                wallExists = true; break; 
                            } 
                        } 
                        if (!wallExists) { 
                            wallsToConsider.push({ c1: this, c2: neighbor, d1: neighborInfo.dir, d2: oppDir }); 
                        } 
                    } 
                } 
            } 
            show() { 
                let x = this.i * cellSize; let y = this.j * cellSize; 
                stroke(150); strokeWeight(2); 
                if (this.walls[0]) line(x, y, x + cellSize, y); 
                if (this.walls[1]) line(x + cellSize, y, x + cellSize, y + cellSize); 
                if (this.walls[2]) line(x + cellSize, y + cellSize, x, y + cellSize); 
                if (this.walls[3]) line(x, y + cellSize, x, y); 
            } 
        }

        function removeWallsBetween(cell1, cell2, dir1, dir2) { cell1.walls[dir1] = false; cell2.walls[dir2] = false; }
        
        function checkPlayerMovementAndCollision() { 
            let dx = 0, dy = 0; 
            if (keyIsDown(87)) { dy = -playerMoveSpeed; playerAngle = -HALF_PI; } 
            if (keyIsDown(83)) { dy = playerMoveSpeed; playerAngle = HALF_PI; } 
            if (keyIsDown(65)) { dx = -playerMoveSpeed; playerAngle = PI; } 
            if (keyIsDown(68)) { dx = playerMoveSpeed; playerAngle = 0; } 
            
            if ((dx !== 0 || dy !== 0) && currentGameMode === 'instagram' && !timerStarted) {
                startTime = millis();
                timerStarted = true;
            }

            if (dx === 0 && dy === 0) return; 
            
            let currentCellI = floor(playerX / cellSize); 
            let currentCellJ = floor(playerY / cellSize); 
            let currentCell = grid[currentCellJ * cols + currentCellI]; 
            if (!currentCell) return; 
            
            let nextPlayerX = playerX + dx, nextPlayerY = playerY + dy; 
            let playerLeft = nextPlayerX - playerSize / 2, playerRight = nextPlayerX + playerSize / 2, playerTop = nextPlayerY - playerSize / 2, playerBottom = nextPlayerY + playerSize / 2; 
            
            if (dx > 0 && currentCell.walls[1] && playerRight > (currentCellI + 1) * cellSize) { 
                playerX = (currentCellI + 1) * cellSize - playerSize / 2; 
            } else if (dx < 0 && currentCell.walls[3] && playerLeft < currentCellI * cellSize) { 
                playerX = currentCellI * cellSize + playerSize / 2; 
            } else { 
                playerX = nextPlayerX; 
            } 
            
            if (dy > 0 && currentCell.walls[2] && playerBottom > (currentCellJ + 1) * cellSize) { 
                playerY = (currentCellJ + 1) * cellSize - playerSize / 2; 
            } else if (dy < 0 && currentCell.walls[0] && playerTop < currentCellJ * cellSize) { 
                playerY = currentCellJ * cellSize + playerSize / 2; 
            } else { 
                playerY = nextPlayerY; 
            } 
        }
    </script>
</body>
</html>
